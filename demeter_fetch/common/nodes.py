#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time    : 2024-01-09 11:21
# @Author  : 32ethers
# @Description:
from datetime import timedelta, date

import os
from typing import List, Dict, Callable

import pandas as pd
from tqdm import tqdm

from ._typing import Config, FromConfig
from .utils import TimeUtil, set_global_pbar


class Node:
    def __init__(self, depends: List):
        self.name = ""
        self.is_daily = False
        self.depends: List[Node] = depends
        self.config: Config | None = None
        self.from_config: FromConfig | None = None
        self.to_path: str | None = None

    def set_config(self, config: Config):
        self.config = config
        self.from_config = config.from_config
        self.to_path = config.to_config.save_path

    def work(self):
        param = {}
        step_file_name = self.get_full_path_by_day()
        if self.config.to_config.skip_existed and os.path.exists(step_file_name):
            return
        for depend in self.depends:
            param[depend.name] = depend.get_full_paths
        df = self._process(param, None)
        df.to_csv(step_file_name, index=False)

    def _process(self, data: Dict[str, List[str]], day: date | None = None) -> pd.DataFrame():
        """
        :param data: Dict[depend_step_name, List[depend step files]],
        :param day:
        :return:
        """
        return pd.DataFrame()

    def get_file_name_by_day(self, day_str: str = "") -> str:
        return f"{self.name}{day_str}.csv"

    def get_full_path_by_day(self, day_str: str = "") -> str:
        return os.path.join(self.to_path, self.get_file_name_by_day(day_str))

    @property
    def get_full_paths(self) -> List[str]:
        return [self.get_full_path_by_day("")]

    @property
    def load_csv_converter(self) -> Dict[str, Callable]:
        """
        if you want to read csv generated by this step with pandas, you have to use those csv converter
        :return:
        """
        return {}

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.name


class DailyNode(Node):
    def __init__(self, depends: List):
        super().__init__(depends)
        self.is_daily = True

    def work(self):
        set_global_pbar(None)
        # if daily, global loop will handle processbar, outfile existence, gather param
        day_idx = self.config.from_config.start
        pbar = tqdm(
            total=(self.config.from_config.end - self.config.from_config.start).days + 1,
            ncols=80,
            position=0,
            leave=False,
        )
        set_global_pbar(pbar)
        while day_idx <= self.config.from_config.end:
            day_str = day_idx.strftime("%Y-%m-%d")
            step_file_name = self.get_full_path_by_day(day_str)
            if self.config.to_config.skip_existed and os.path.exists(step_file_name):
                continue
            param = {}
            for depend in self.depends:
                if depend.is_daily:
                    depend_file_path = depend.get_full_path_by_day(day_str)
                    param[depend.name] = pd.read_csv(depend_file_path, converters=depend.load_csv_converter)
                    pass
                else:
                    depend_file_path = depend.get_full_path_by_day("")
                    param[depend.name] = pd.read_csv(depend_file_path, converters=depend.load_csv_converter)
                    pass
            df = self._process_one_day(param, day_idx)
            df.to_csv(self.get_full_path_by_day(day_str), index=False)
            day_idx += timedelta(days=1)
            pbar.update()

    def _process_one_day(self, data: Dict[str, pd.DataFrame], day: date) -> pd.DataFrame:
        return pd.DataFrame()

    @property
    def get_full_paths(self) -> List[str]:
        return [
            self.get_full_path_by_day(day.strftime("%Y-%m-%d"))
            for day in TimeUtil.get_date_array(self.from_config.start, self.from_config.end)
        ]
